name: Production Deployment

on:
  push:
    branches:
      - main

env:
  NODE_VERSION: '20'
  WRANGLER_VERSION: '3.78.0'

jobs:
  detect-changed-workers:
    name: Detect Changed Workers
    runs-on: ubuntu-latest
    outputs:
      workers: ${{ steps.detect.outputs.workers }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed workers
        id: detect
        run: |
          PREV_SHA="${{ github.event.before }}"
          CURRENT_SHA="${{ github.sha }}"
          
          # If this is the first commit, compare with empty tree
          if [ "$PREV_SHA" = "0000000000000000000000000000000000000000" ]; then
            PREV_SHA=$(git rev-parse HEAD~1 2>/dev/null || echo "")
          fi
          
          if [ -z "$PREV_SHA" ]; then
            echo "No previous commit found - deploying all workers"
            WORKERS_TO_DEPLOY=(
              "authworker"
              "catalogworker"
              "pricingworker"
              "fulfillmentworker"
              "cartworker"
              "paymentworker"
              "ordersworker"
              "ratingworker"
              "realtimeworker"
              "logworker"
              "healthcheckworker"
            )
          else
            echo "Comparing ${PREV_SHA}..${CURRENT_SHA}"
            
            # Get all changed files
            CHANGED_FILES=$(git diff --name-only ${PREV_SHA}..${CURRENT_SHA} || echo "")
            
            if [ -z "$CHANGED_FILES" ]; then
              echo "No changed files detected"
              echo "has-changes=false" >> $GITHUB_OUTPUT
              echo "workers=" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            echo ""
            
            # Workers that need deployment
            WORKERS_TO_DEPLOY=()
            
            # Check each worker directory
            if echo "$CHANGED_FILES" | grep -q "^authworker/"; then
              WORKERS_TO_DEPLOY+=("authworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^catalogworker/"; then
              WORKERS_TO_DEPLOY+=("catalogworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^pricingworker/"; then
              WORKERS_TO_DEPLOY+=("pricingworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^fulfillmentworker/"; then
              WORKERS_TO_DEPLOY+=("fulfillmentworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^cartworker/"; then
              WORKERS_TO_DEPLOY+=("cartworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^paymentworker/"; then
              WORKERS_TO_DEPLOY+=("paymentworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^ordersworker/"; then
              WORKERS_TO_DEPLOY+=("ordersworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^ratingworker/"; then
              WORKERS_TO_DEPLOY+=("ratingworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^realtimeworker/"; then
              WORKERS_TO_DEPLOY+=("realtimeworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^logworker/"; then
              WORKERS_TO_DEPLOY+=("logworker")
            fi
            if echo "$CHANGED_FILES" | grep -q "^healthcheckworker/"; then
              WORKERS_TO_DEPLOY+=("healthcheckworker")
            fi
            
            # Check for shared code changes - affects all workers
            if echo "$CHANGED_FILES" | grep -q "^shared/"; then
              echo "⚠️  Shared code changed - will deploy all workers"
              WORKERS_TO_DEPLOY=(
                "authworker"
                "catalogworker"
                "pricingworker"
                "fulfillmentworker"
                "cartworker"
                "paymentworker"
                "ordersworker"
                "ratingworker"
                "realtimeworker"
                "logworker"
                "healthcheckworker"
              )
            fi
            
            # Check for package.json or package-lock.json changes - affects all workers
            if echo "$CHANGED_FILES" | grep -qE "^(package\.json|package-lock\.json)$"; then
              echo "⚠️  Package files changed - will deploy all workers"
              WORKERS_TO_DEPLOY=(
                "authworker"
                "catalogworker"
                "pricingworker"
                "fulfillmentworker"
                "cartworker"
                "paymentworker"
                "ordersworker"
                "ratingworker"
                "realtimeworker"
                "logworker"
                "healthcheckworker"
              )
            fi
            
            # Check for wrangler config changes - deploy affected worker
            for config in wrangler.*.toml; do
              if echo "$CHANGED_FILES" | grep -q "^${config}$"; then
                WORKER_NAME=$(echo "$config" | sed 's/wrangler\.\(.*\)\.toml/\1/')
                if [[ ! " ${WORKERS_TO_DEPLOY[@]} " =~ " ${WORKER_NAME} " ]]; then
                  WORKERS_TO_DEPLOY+=("$WORKER_NAME")
                fi
              fi
            done
            
            # Remove duplicates and sort
            UNIQUE_WORKERS=($(printf '%s\n' "${WORKERS_TO_DEPLOY[@]}" | sort -u))
          fi
          
          if [ ${#UNIQUE_WORKERS[@]} -eq 0 ]; then
            echo "No workers need deployment"
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "workers=[]" >> $GITHUB_OUTPUT
          else
            echo "Workers to deploy: ${UNIQUE_WORKERS[*]}"
            echo "has-changes=true" >> $GITHUB_OUTPUT
            # Create JSON array properly - use compact format
            WORKERS_JSON=$(printf '%s\n' "${UNIQUE_WORKERS[@]}" | jq -R . | jq -s . | jq -c . 2>/dev/null || echo "[]")
            if [ "$WORKERS_JSON" = "[]" ] || [ -z "$WORKERS_JSON" ]; then
              echo "Error: Failed to create workers JSON, defaulting to empty array"
              echo "workers=[]" >> $GITHUB_OUTPUT
            else
              # Use multiline output format for GitHub Actions
              {
                echo "workers<<EOF"
                echo "$WORKERS_JSON"
                echo "EOF"
              } >> $GITHUB_OUTPUT
            fi
          fi

  store-production-deployments:
    name: Store Current Production Deployment IDs
    runs-on: ubuntu-latest
    needs: detect-changed-workers
    if: needs.detect-changed-workers.outputs.has-changes == 'true'
    outputs:
      deployment-ids: ${{ steps.store.outputs.ids }}
      deployment-shas: ${{ steps.store.outputs.shas }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for SHA comparison

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Wrangler
        run: npm install -g wrangler@${{ env.WRANGLER_VERSION }}

      - name: Authenticate with Cloudflare
        run: |
          export CLOUDFLARE_API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
          export CLOUDFLARE_ACCOUNT_ID="${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          # Verify authentication
          wrangler whoami
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Get changed workers list
        id: workers-list
        run: |
          WORKERS_JSON='${{ needs.detect-changed-workers.outputs.workers }}'
          if [ "$WORKERS_JSON" != "[]" ] && [ -n "$WORKERS_JSON" ]; then
            echo "$WORKERS_JSON" | jq -r '.[]' > workers-list.txt
            echo "Workers to process:"
            cat workers-list.txt
          else
            echo "No workers to process"
            touch workers-list.txt
          fi

      - name: Get current production deployment IDs and SHAs
        id: store
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          DEPLOYMENT_IDS=""
          DEPLOYMENT_SHAS=""
          CURRENT_SHA="${{ github.sha }}"
          
          echo "Current commit SHA: ${CURRENT_SHA}"
          
          while IFS= read -r worker; do
            CONFIG_FILE="wrangler.${worker}.toml"
            if [ -f "$CONFIG_FILE" ]; then
              echo "Getting production deployment info for ${worker}..."
              
              # Get the latest deployment ID
              DEPLOYMENT_ID=$(wrangler deployments list --config "$CONFIG_FILE" --format json | jq -r '.[0].id // empty' 2>/dev/null || echo "")
              
              # Get the deployment message/version which might contain SHA
              DEPLOYMENT_INFO=$(wrangler deployments list --config "$CONFIG_FILE" --format json | jq -r '.[0] // empty' 2>/dev/null || echo "")
              
              if [ -n "$DEPLOYMENT_ID" ]; then
                echo "${worker}_deployment_id=${DEPLOYMENT_ID}" >> $GITHUB_OUTPUT
                DEPLOYMENT_IDS="${DEPLOYMENT_IDS}${worker}:${DEPLOYMENT_ID};"
                
                # Try to extract SHA from deployment info
                DEPLOYMENT_SHA=$(echo "$DEPLOYMENT_INFO" | jq -r '.version.message // .version.id // empty' 2>/dev/null || echo "")
                if [ -z "$DEPLOYMENT_SHA" ]; then
                  # Fallback: use current HEAD SHA before this commit
                  DEPLOYMENT_SHA=$(git rev-parse HEAD~1 2>/dev/null || echo "")
                fi
                
                echo "${worker}_deployment_sha=${DEPLOYMENT_SHA}" >> $GITHUB_OUTPUT
                DEPLOYMENT_SHAS="${DEPLOYMENT_SHAS}${worker}:${DEPLOYMENT_SHA};"
                
                echo "Stored deployment ID for ${worker}: ${DEPLOYMENT_ID}"
                echo "Stored deployment SHA for ${worker}: ${DEPLOYMENT_SHA}"
              else
                echo "Warning: Could not get deployment ID for ${worker}"
                echo "${worker}_deployment_id=" >> $GITHUB_OUTPUT
                echo "${worker}_deployment_sha=" >> $GITHUB_OUTPUT
              fi
            fi
          done < workers-list.txt
          
          # Store all IDs and SHAs as single outputs
          echo "ids=${DEPLOYMENT_IDS}" >> $GITHUB_OUTPUT
          echo "shas=${DEPLOYMENT_SHAS}" >> $GITHUB_OUTPUT
          
          # Also store in environment file for other jobs
          echo "DEPLOYMENT_IDS=${DEPLOYMENT_IDS}" >> $GITHUB_ENV
          echo "DEPLOYMENT_SHAS=${DEPLOYMENT_SHAS}" >> $GITHUB_ENV
          
          # Save to files for artifact upload
          echo "$DEPLOYMENT_IDS" > deployment-ids.txt
          echo "$DEPLOYMENT_SHAS" > deployment-shas.txt

      - name: Upload deployment info artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: |
            deployment-ids.txt
            deployment-shas.txt
          retention-days: 30

  lint-and-test:
    name: Lint and Test
    runs-on: ubuntu-latest
    needs: detect-changed-workers
    if: needs.detect-changed-workers.outputs.has-changes == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter (if available)
        continue-on-error: true
        run: |
          if npm run lint 2>/dev/null; then
            echo "Lint passed"
          else
            echo "No lint script found or lint failed, continuing..."
          fi

      - name: Run tests
        run: npm test

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            coverage/
            test-results.xml
          retention-days: 30

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [detect-changed-workers, store-production-deployments, lint-and-test]
    if: success() && needs.detect-changed-workers.outputs.has-changes == 'true'
    environment:
      name: production
      url: https://production-deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Wrangler
        run: npm install -g wrangler@${{ env.WRANGLER_VERSION }}

      - name: Authenticate with Cloudflare
        run: |
          export CLOUDFLARE_API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
          export CLOUDFLARE_ACCOUNT_ID="${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          # Verify authentication
          wrangler whoami
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Get changed workers list
        run: |
          WORKERS_JSON='${{ needs.detect-changed-workers.outputs.workers }}'
          echo "$WORKERS_JSON" | jq -r '.[]' > workers-list.txt
          echo "Deploying workers:"
          cat workers-list.txt

      - name: Deploy to production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          FAILED_WORKERS=()
          CURRENT_SHA="${{ github.sha }}"
          
          while IFS= read -r worker; do
            CONFIG_FILE="wrangler.${worker}.toml"
            if [ -f "$CONFIG_FILE" ]; then
              echo "Deploying ${worker} to production..."
              if wrangler deploy --config "$CONFIG_FILE" --message "Deploy ${CURRENT_SHA}" 2>&1; then
                echo "✅ Successfully deployed ${worker} to production"
              else
                echo "❌ Failed to deploy ${worker} to production"
                FAILED_WORKERS+=("$worker")
              fi
            fi
          done < workers-list.txt
          
          if [ ${#FAILED_WORKERS[@]} -gt 0 ]; then
            echo "Some workers failed to deploy: ${FAILED_WORKERS[*]}"
            exit 1
          fi

  rollback-on-failure:
    name: Rollback Production on Failure
    runs-on: ubuntu-latest
    needs: [detect-changed-workers, store-production-deployments, lint-and-test, deploy-production]
    if: failure() && needs.detect-changed-workers.outputs.has-changes == 'true' && (needs.lint-and-test.result == 'failure' || needs.deploy-production.result == 'failure')
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Wrangler
        run: npm install -g wrangler@${{ env.WRANGLER_VERSION }}

      - name: Authenticate with Cloudflare
        run: |
          export CLOUDFLARE_API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
          export CLOUDFLARE_ACCOUNT_ID="${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          # Verify authentication
          wrangler whoami
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Download stored deployment info
        uses: actions/download-artifact@v4
        with:
          name: deployment-info
          path: ./

      - name: Get changed workers list
        run: |
          WORKERS_JSON='${{ needs.detect-changed-workers.outputs.workers }}'
          echo "$WORKERS_JSON" | jq -r '.[]' > workers-list.txt

      - name: Rollback production deployments
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Get stored deployment IDs from artifact or job output
          if [ -f "deployment-ids.txt" ]; then
            DEPLOYMENT_IDS=$(cat deployment-ids.txt)
          else
            DEPLOYMENT_IDS="${{ needs.store-production-deployments.outputs.deployment-ids }}"
          fi
          
          echo "⚠️  Rolling back production deployments due to test/deployment failure..."
          echo "Stored deployment IDs: ${DEPLOYMENT_IDS}"
          
          ROLLBACK_FAILED=0
          
          while IFS= read -r worker; do
            CONFIG_FILE="wrangler.${worker}.toml"
            if [ -f "$CONFIG_FILE" ]; then
              # Extract deployment ID for this worker using sed (more portable)
              DEPLOYMENT_ID=$(echo "$DEPLOYMENT_IDS" | sed -n "s/.*${worker}:\([^;]*\);.*/\1/p" | head -1)
              
              if [ -n "$DEPLOYMENT_ID" ]; then
                echo "Rolling back ${worker} to deployment ${DEPLOYMENT_ID}..."
                if wrangler rollback --config "$CONFIG_FILE" --message "Emergency rollback after failed production deployment" 2>&1; then
                  echo "✅ Successfully rolled back ${worker}"
                else
                  echo "❌ Failed to rollback ${worker}"
                  ROLLBACK_FAILED=1
                fi
              else
                echo "⚠️  No stored deployment ID for ${worker}, attempting automatic rollback..."
                if wrangler rollback --config "$CONFIG_FILE" 2>&1; then
                  echo "✅ Successfully rolled back ${worker} (automatic)"
                else
                  echo "❌ Failed to rollback ${worker} (automatic)"
                  ROLLBACK_FAILED=1
                fi
              fi
            fi
          done < workers-list.txt
          
          if [ $ROLLBACK_FAILED -eq 1 ]; then
            echo "❌ Some workers failed to rollback. Manual intervention may be required."
            exit 1
          else
            echo "✅ All workers rolled back successfully"
          fi

